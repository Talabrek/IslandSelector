---
phase: 12-core-capture-and-restore
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/main/java/world/bentobox/islandselector/integrations/NovaIntegration.java
autonomous: true

must_haves:
  truths:
    - "System captures all Nova blocks including TileEntity drops before operations"
    - "System removes Nova blocks via BlockUtils.breakBlock() with Context.EMPTY"
    - "NovaBlockData stores drops for state preservation during capture/restore cycle"
  artifacts:
    - path: "src/main/java/world/bentobox/islandselector/integrations/NovaIntegration.java"
      provides: "Enhanced capture with drops, new removeNovaBlocks method"
      contains: "removeNovaBlocks"
      exports: ["captureNovaBlocks", "removeNovaBlocks", "NovaBlockData"]
  key_links:
    - from: "captureNovaBlocks"
      to: "WorldDataManager.getTileEntity"
      via: "reflection invoke"
      pattern: "getTileEntity.*invoke"
    - from: "captureNovaBlocks"
      to: "TileEntity.getDrops"
      via: "reflection invoke"
      pattern: "getDrops.*invoke.*true"
    - from: "removeNovaBlocks"
      to: "BlockUtils.breakBlock"
      via: "reflection invoke"
      pattern: "breakBlock.*invoke"
---

<objective>
Enhance NovaIntegration with TileEntity drop capture and proper block removal lifecycle.

Purpose: Enable Nova blocks to be captured with full state (inventory, owner via drops) and properly removed before WorldEdit operations. This is the core capture/remove foundation that Phase 13 (State Preservation) will build upon for drop restoration.

Output:
- Enhanced NovaBlockData class with drops field for state preservation
- Enhanced captureNovaBlocks() that captures TileEntity drops
- New removeNovaBlocks() method using BlockUtils.breakBlock() with Context.EMPTY
</objective>

<execution_context>
@C:\Users\Administrator\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\Administrator\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/12-core-capture-and-restore/12-RESEARCH.md
@src/main/java/world/bentobox/islandselector/integrations/NovaIntegration.java
</context>

<tasks>

<task type="auto">
  <name>Task 1: Enhance NovaBlockData and captureNovaBlocks with TileEntity drops</name>
  <files>src/main/java/world/bentobox/islandselector/integrations/NovaIntegration.java</files>
  <action>
Modify NovaIntegration.java to capture TileEntity drops:

1. **Update NovaBlockData inner class** (currently lines 357-369):
   - Add `import org.bukkit.inventory.ItemStack;` at top of file
   - Increment serialVersionUID to 2L
   - Add `public final List<ItemStack> drops;` field
   - Add new constructor with drops parameter: `NovaBlockData(int relX, int relY, int relZ, String blockId, List<ItemStack> drops)`
   - Keep old constructor for backward compatibility (passes null for drops)

2. **Enhance captureNovaBlocks method** (currently lines 108-176):
   - After getting worldDataManager and getBlockStateMethod, add getTileEntity method lookup:
     ```java
     java.lang.reflect.Method getTileEntityMethod = worldDataManagerClass.getMethod(
         "getTileEntity", Location.class
     );
     ```
   - Get TileEntity class for getDrops method:
     ```java
     Class<?> tileEntityClass = Class.forName("xyz.xenondevs.nova.world.block.tileentity.TileEntity");
     java.lang.reflect.Method getDropsMethod = tileEntityClass.getMethod("getDrops", boolean.class);
     ```
   - Inside the block iteration loop, after getting blockId and before creating NovaBlockData:
     ```java
     // Capture TileEntity drops if this is a tile entity block
     List<ItemStack> drops = null;
     try {
         Object tileEntity = getTileEntityMethod.invoke(worldDataManager, loc);
         if (tileEntity != null) {
             @SuppressWarnings("unchecked")
             List<ItemStack> capturedDrops = (List<ItemStack>) getDropsMethod.invoke(tileEntity, true);
             drops = capturedDrops;
         }
     } catch (Exception te) {
         // Not a tile entity or getDrops failed - drops stays null
     }
     ```
   - Update NovaBlockData creation to use new constructor with drops

3. **Update log message** to indicate drops captured:
   - Change "Captured X Nova blocks" to "Captured X Nova blocks (Y with tile entity data)"
   - Count blocks where drops != null

IMPORTANT: Do NOT add new imports for ItemStack if already present. Check existing imports first.
IMPORTANT: The TileEntity class path for Nova 0.17+ is `xyz.xenondevs.nova.world.block.tileentity.TileEntity`.
  </action>
  <verify>
    - `mvn clean compile -q` succeeds
    - NovaBlockData has drops field and two constructors
    - captureNovaBlocks calls getTileEntity and getDrops via reflection
  </verify>
  <done>
    - NovaBlockData class has List<ItemStack> drops field
    - captureNovaBlocks captures TileEntity drops for blocks that have them
    - Log message shows count of blocks with tile entity data
  </done>
</task>

<task type="auto">
  <name>Task 2: Add removeNovaBlocks method using BlockUtils.breakBlock</name>
  <files>src/main/java/world/bentobox/islandselector/integrations/NovaIntegration.java</files>
  <action>
Add new removeNovaBlocks method to NovaIntegration.java. Insert after restoreNovaBlocksAsync method (after line 352):

```java
/**
 * Remove Nova blocks before WorldEdit operations.
 * Must be called AFTER captureNovaBlocks and BEFORE WorldEdit paste.
 * Uses BlockUtils.breakBlock() for proper Nova lifecycle cleanup.
 *
 * @param novaBlocks List of Nova blocks captured earlier
 * @param center Center location where blocks were captured
 */
public void removeNovaBlocks(List<NovaBlockData> novaBlocks, Location center) {
    if (!available || novaBlocks == null || novaBlocks.isEmpty()) {
        return;
    }

    World world = center.getWorld();
    if (world == null) {
        return;
    }

    int centerX = center.getBlockX();
    int centerY = center.getBlockY();
    int centerZ = center.getBlockZ();
    int removed = 0;

    try {
        // Get BlockUtils class
        Class<?> blockUtilsClass = Class.forName("xyz.xenondevs.nova.util.BlockUtils");

        // Get Context.EMPTY for automated operations (no player involved)
        Class<?> contextClass = Class.forName("xyz.xenondevs.nova.context.Context");
        Object emptyContext = null;

        // Try EMPTY field first (companion object in Kotlin)
        try {
            java.lang.reflect.Field emptyField = contextClass.getDeclaredField("EMPTY");
            emptyContext = emptyField.get(null);
        } catch (NoSuchFieldException e1) {
            // Try empty() method as fallback
            try {
                java.lang.reflect.Method emptyMethod = contextClass.getMethod("empty");
                emptyContext = emptyMethod.invoke(null);
            } catch (NoSuchMethodException e2) {
                addon.logWarning("Cannot get empty Nova context - skipping block removal");
                return;
            }
        }

        if (emptyContext == null) {
            addon.logWarning("Nova context is null - skipping block removal");
            return;
        }

        // Get breakBlock method: breakBlock(Context, Location, boolean breakEffects)
        java.lang.reflect.Method breakBlockMethod = blockUtilsClass.getMethod(
            "breakBlock",
            contextClass,
            Location.class,
            boolean.class
        );

        final Object finalContext = emptyContext;

        for (NovaBlockData data : novaBlocks) {
            try {
                Location loc = new Location(world,
                    centerX + data.relX,
                    centerY + data.relY,
                    centerZ + data.relZ);

                // Break the block silently (no effects, no drops - we already captured them)
                breakBlockMethod.invoke(null, finalContext, loc, false);
                removed++;

            } catch (Exception e) {
                // Skip blocks that fail - may have been removed already or aren't Nova blocks
                if (addon.getSettings().isDebugEnabled()) {
                    addon.log("Failed to remove Nova block at " + data.relX + "," + data.relY + "," + data.relZ + ": " + e.getMessage());
                }
            }
        }

        addon.log("Removed " + removed + "/" + novaBlocks.size() + " Nova blocks before WorldEdit operation");

    } catch (ClassNotFoundException e) {
        addon.logWarning("Nova BlockUtils class not found - cannot remove blocks: " + e.getMessage());
    } catch (NoSuchMethodException e) {
        addon.logWarning("Nova breakBlock method not found - API may have changed: " + e.getMessage());
    } catch (Exception e) {
        addon.logWarning("Failed to remove Nova blocks: " + e.getMessage());
    }
}

/**
 * Remove Nova blocks asynchronously (ensures chunks are loaded first)
 */
public void removeNovaBlocksAsync(List<NovaBlockData> novaBlocks, Location center, Consumer<Boolean> callback) {
    if (!available || novaBlocks == null || novaBlocks.isEmpty()) {
        callback.accept(true);
        return;
    }

    World world = center.getWorld();
    if (world == null) {
        callback.accept(false);
        return;
    }

    int centerX = center.getBlockX();
    int centerZ = center.getBlockZ();

    // Find the range from captured blocks
    int minX = Integer.MAX_VALUE, maxX = Integer.MIN_VALUE;
    int minZ = Integer.MAX_VALUE, maxZ = Integer.MIN_VALUE;
    for (NovaBlockData data : novaBlocks) {
        minX = Math.min(minX, centerX + data.relX);
        maxX = Math.max(maxX, centerX + data.relX);
        minZ = Math.min(minZ, centerZ + data.relZ);
        maxZ = Math.max(maxZ, centerZ + data.relZ);
    }

    // Calculate chunks to load
    int minChunkX = minX >> 4;
    int maxChunkX = maxX >> 4;
    int minChunkZ = minZ >> 4;
    int maxChunkZ = maxZ >> 4;

    List<CompletableFuture<org.bukkit.Chunk>> chunkFutures = new ArrayList<>();
    for (int cx = minChunkX; cx <= maxChunkX; cx++) {
        for (int cz = minChunkZ; cz <= maxChunkZ; cz++) {
            chunkFutures.add(world.getChunkAtAsync(cx, cz));
        }
    }

    CompletableFuture.allOf(chunkFutures.toArray(new CompletableFuture[0]))
        .orTimeout(30, java.util.concurrent.TimeUnit.SECONDS)
        .thenRun(() -> {
            // Chunks loaded, now remove on main thread
            Bukkit.getScheduler().runTask(addon.getPlugin(), () -> {
                removeNovaBlocks(novaBlocks, center);
                callback.accept(true);
            });
        })
        .exceptionally(throwable -> {
            addon.logWarning("Nova block removal timed out: " + throwable.getMessage());
            Bukkit.getScheduler().runTask(addon.getPlugin(), () -> {
                callback.accept(false);
            });
            return null;
        });
}
```

IMPORTANT: The breakBlock method signature in Nova 0.17+ is `breakBlock(Context, Location, boolean)` where boolean is breakEffects (particle/sound effects). Use false for silent removal.
IMPORTANT: Context is a Kotlin class with companion object field EMPTY. Access via reflection on the class.
  </action>
  <verify>
    - `mvn clean compile -q` succeeds
    - NovaIntegration has removeNovaBlocks(List, Location) method
    - NovaIntegration has removeNovaBlocksAsync(List, Location, Consumer) method
    - Methods use BlockUtils.breakBlock via reflection
  </verify>
  <done>
    - removeNovaBlocks method exists and uses BlockUtils.breakBlock with Context.EMPTY
    - removeNovaBlocksAsync method exists for async chunk loading
    - Log message shows removal count
  </done>
</task>

<task type="auto">
  <name>Task 3: Build verification and final review</name>
  <files>src/main/java/world/bentobox/islandselector/integrations/NovaIntegration.java</files>
  <action>
1. Run full build to verify no compile errors:
   ```bash
   mvn clean package -q
   ```

2. Review NovaIntegration.java to verify:
   - NovaBlockData has drops field and both constructors
   - captureNovaBlocks captures TileEntity drops via reflection
   - removeNovaBlocks uses BlockUtils.breakBlock with Context.EMPTY
   - All async methods have proper timeout handling
   - Log messages are informative

3. Verify the lifecycle documentation in code comments matches the expected order:
   - capture (with drops) -> remove -> WorldEdit -> restore

4. If build fails, fix any issues found.
  </action>
  <verify>
    - `mvn clean package -q` produces target/IslandSelector-1.0.0.jar
    - No compile warnings related to Nova integration
    - JAR file contains compiled NovaIntegration.class
  </verify>
  <done>
    - Build passes without errors
    - NovaIntegration has all three core methods: captureNovaBlocks (enhanced), removeNovaBlocks (new), restoreNovaBlocks (existing)
    - Phase 12 requirements NOVA-02, NOVA-04 addressed (NOVA-03 partially - restore exists, drop restoration in Phase 13)
  </done>
</task>

</tasks>

<verification>
After all tasks complete:

1. **Structural verification:**
   - NovaBlockData has drops field: `grep -n "drops" NovaIntegration.java`
   - removeNovaBlocks exists: `grep -n "removeNovaBlocks" NovaIntegration.java`
   - breakBlock called: `grep -n "breakBlock" NovaIntegration.java`

2. **Build verification:**
   - `mvn clean package -q` succeeds
   - JAR created in target/

3. **Requirements coverage:**
   - NOVA-02: captureNovaBlocks captures TileEntity drops (state preservation foundation)
   - NOVA-04: removeNovaBlocks uses BlockUtils.breakBlock() (proper Nova lifecycle)
   - NOVA-03: restoreNovaBlocks exists (enhanced drop restoration in Phase 13)
</verification>

<success_criteria>
- [ ] NovaBlockData class has List<ItemStack> drops field with serialVersionUID = 2L
- [ ] captureNovaBlocks uses WorldDataManager.getTileEntity() and TileEntity.getDrops(true)
- [ ] removeNovaBlocks method exists using BlockUtils.breakBlock(Context.EMPTY, loc, false)
- [ ] removeNovaBlocksAsync method exists with chunk loading and timeout
- [ ] `mvn clean package -q` produces JAR without errors
- [ ] Log messages indicate capture count with tile entity data and removal count
</success_criteria>

<output>
After completion, create `.planning/phases/12-core-capture-and-restore/12-01-SUMMARY.md`
</output>
