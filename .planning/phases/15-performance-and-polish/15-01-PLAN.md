---
phase: 15-performance-and-polish
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/main/java/world/bentobox/islandselector/integrations/NovaIntegration.java
autonomous: true

must_haves:
  truths:
    - "Reflection method lookups happen once at initialization, not per-operation"
    - "Nova block scanning completes in under 5 seconds for typical islands"
    - "Large islands (100+ Nova blocks) process without server lag"
    - "Debug mode shows timing information for performance verification"
  artifacts:
    - path: "src/main/java/world/bentobox/islandselector/integrations/NovaIntegration.java"
      provides: "Reflection caching and performance-optimized Nova integration"
      contains: "class ReflectionCache"
  key_links:
    - from: "NovaIntegration constructor"
      to: "ReflectionCache initialization"
      via: "final field assignment"
      pattern: "this\\.cache = .* new ReflectionCache"
    - from: "captureNovaBlocks/restoreNovaBlocks/removeNovaBlocks"
      to: "cache.xxxMethod.invoke"
      via: "cached method invocation"
      pattern: "cache\\.[a-zA-Z]+Method\\.invoke"
---

<objective>
Optimize Nova integration by caching all reflection lookups and adding performance timing.

Purpose: Eliminate 2-10x overhead from repeated reflection method lookups that occur on every Nova operation. The current implementation looks up classes, fields, and methods inside every method call (captureNovaBlocks, restoreNovaBlocks, removeNovaBlocks), which is inefficient for islands with many Nova blocks.

Output: Refactored NovaIntegration.java with ReflectionCache inner class containing all cached reflection objects, used across all operations.
</objective>

<execution_context>
@C:\Users\Administrator\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\Administrator\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/15-performance-and-polish/15-RESEARCH.md
@src/main/java/world/bentobox/islandselector/integrations/NovaIntegration.java
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create ReflectionCache inner class with all cached reflection objects</name>
  <files>src/main/java/world/bentobox/islandselector/integrations/NovaIntegration.java</files>
  <action>
Add a private static inner class `ReflectionCache` that caches all Nova API reflection lookups. This class should:

1. Have final fields for ALL classes used in Nova operations:
   - worldDataManagerClass (xyz.xenondevs.nova.world.format.WorldDataManager)
   - tileEntityClass (xyz.xenondevs.nova.world.block.tileentity.TileEntity)
   - blockUtilsClass (xyz.xenondevs.nova.util.BlockUtils)
   - contextClass (xyz.xenondevs.nova.context.Context)
   - keyClass (net.kyori.adventure.key.Key)
   - novaRegistriesClass (xyz.xenondevs.nova.registry.NovaRegistries)
   - novaBlockClass (xyz.xenondevs.nova.world.block.NovaBlock)

2. Have final fields for singleton instances:
   - worldDataManagerInstance (from WorldDataManager.INSTANCE)
   - blockRegistry (from NovaRegistries.BLOCK)
   - emptyContext (from Context.EMPTY field or Context.empty() method)

3. Have final fields for ALL methods used:
   - getBlockStateMethod (WorldDataManager.getBlockState(Location))
   - getTileEntityMethod (WorldDataManager.getTileEntity(Location))
   - getDropsMethod (TileEntity.getDrops(boolean))
   - getIdMethod (will need to be looked up from NovaBlockState at runtime, or cache the Method object from first success)
   - breakBlockMethod (BlockUtils.breakBlock(Context, Location, boolean))
   - placeBlockMethod (BlockUtils.placeBlock(Context, Location, NovaBlock, boolean))
   - keyMethod (Key.key(String))
   - registryGetMethod (blockRegistry.get(Key))

4. Constructor throws ReflectiveOperationException on ANY failure (fail-fast pattern). The entire cache is either fully initialized or null.

5. Add a private final field `ReflectionCache cache` to NovaIntegration class (nullable).

6. Initialize cache in constructor AFTER detectNova() returns true. Wrap in try-catch, set cache=null on failure and log warning.

Pattern from research:
```java
private static class ReflectionCache {
    // All fields final for thread-safety
    final Class<?> worldDataManagerClass;
    final Object worldDataManagerInstance;
    final Method getBlockStateMethod;
    // ... etc

    ReflectionCache() throws ReflectiveOperationException {
        // Initialize ALL lookups ONCE
        this.worldDataManagerClass = Class.forName("xyz.xenondevs.nova.world.format.WorldDataManager");
        this.worldDataManagerInstance = worldDataManagerClass.getField("INSTANCE").get(null);
        if (worldDataManagerInstance == null) {
            throw new IllegalStateException("Nova WorldDataManager INSTANCE is null");
        }
        // ... etc for all fields
    }
}

private final ReflectionCache cache;

public NovaIntegration(IslandSelector addon) {
    this.addon = addon;
    this.available = detectNova();

    ReflectionCache tempCache = null;
    if (available) {
        try {
            tempCache = new ReflectionCache();
        } catch (Exception e) {
            addon.logWarning("Failed to initialize Nova reflection cache: " + e.getMessage());
        }
    }
    this.cache = tempCache;

    if (available && cache != null) {
        addon.log("Nova integration enabled - custom block support active");
    } else if (available && cache == null) {
        addon.logWarning("Nova detected but reflection cache failed - integration disabled");
    }
}
```

IMPORTANT: The getIdMethod is tricky because it's called on the blockState object returned from getBlockStateMethod. The blockState is a NovaBlockState which has getId(). Cache the Method object once we know the class. You can either:
- Cache novaBlockStateClass and look up getId() on it
- Or leave getIdMethod as nullable and look it up once on first blockState instance

Choose option 1 (cache novaBlockStateClass.getMethod("getId")) for consistency.
  </action>
  <verify>
Run `mvn clean compile -q` - should compile without errors. The cache class should be defined and initialized in constructor.
  </verify>
  <done>
ReflectionCache inner class exists with all 7+ cached classes, 3+ singleton instances, and 8+ cached methods. NovaIntegration has a final `cache` field initialized in constructor.
  </done>
</task>

<task type="auto">
  <name>Task 2: Refactor all methods to use cached reflection and add timing</name>
  <files>src/main/java/world/bentobox/islandselector/integrations/NovaIntegration.java</files>
  <action>
Refactor captureNovaBlocks(), restoreNovaBlocks(), and removeNovaBlocks() to use the ReflectionCache instead of looking up classes/methods each time.

1. **captureNovaBlocks() refactor:**
   - Replace ALL Class.forName() calls with cache.xxxClass
   - Replace ALL getMethod() calls with cache.xxxMethod
   - Replace ALL getField("INSTANCE").get(null) with cache.xxxInstance
   - Add early exit: `if (cache == null) return novaBlocks;`
   - Reuse single Location object in the loop (avoid allocation overhead):
     ```java
     Location loc = new Location(world, 0, 0, 0);
     for (...) {
         loc.setX(x); loc.setY(y); loc.setZ(z);
         Object blockState = cache.getBlockStateMethod.invoke(cache.worldDataManagerInstance, loc);
     }
     ```
   - Add debug timing at start and end:
     ```java
     long startTime = System.nanoTime();
     // ... scanning logic ...
     if (addon.getSettings().isDebugEnabled()) {
         long elapsedMs = (System.nanoTime() - startTime) / 1_000_000;
         addon.log(String.format("Nova scan: %d blocks found in %dms (range=%d)",
             novaBlocks.size(), elapsedMs, range));
     }
     ```

2. **restoreNovaBlocks() refactor:**
   - Replace ALL Class.forName() calls with cache.xxxClass
   - Replace ALL getMethod() calls with cache.xxxMethod
   - Replace ALL getField() calls with cache.xxxInstance or cache.xxxField
   - Add early exit: `if (cache == null) return new RestoreResult(0, 0);`
   - Use cache.emptyContext instead of looking up Context.EMPTY each time
   - Use cache.keyMethod instead of looking up Key.key() each time
   - Use cache.registryGetMethod and cache.blockRegistry instead of looking them up
   - Use cache.placeBlockMethod instead of looking it up
   - Add debug timing similar to captureNovaBlocks

3. **removeNovaBlocks() refactor:**
   - Replace ALL Class.forName() calls with cache.xxxClass
   - Replace ALL getMethod() calls with cache.xxxMethod
   - Add early exit: `if (cache == null) return;`
   - Use cache.emptyContext instead of looking up Context.EMPTY
   - Use cache.breakBlockMethod instead of looking it up
   - Add debug timing similar to captureNovaBlocks

4. **Keep try-catch for invoke() calls** - method invocation can still fail at runtime (e.g., if Nova data is corrupted). The try-catch should be INSIDE the loop for individual block failures, not around the entire loop.

5. **Remove the old Class/Method lookups** - delete all the Class.forName(), getMethod(), getField() calls that are now handled by cache.

6. **Update isAvailable() logic** - consider checking `cache != null` as part of availability:
   ```java
   public boolean isAvailable() {
       return available && cache != null;
   }
   ```
   This ensures that if cache initialization failed, we don't claim Nova is available.

Pattern from research for timing:
```java
public List<NovaBlockData> captureNovaBlocks(Location center, int range) {
    long startTime = System.nanoTime();
    List<NovaBlockData> novaBlocks = new ArrayList<>();

    if (!available || cache == null) {
        return novaBlocks;
    }
    // ... rest of method ...

    if (addon.getSettings().isDebugEnabled()) {
        long elapsedMs = (System.nanoTime() - startTime) / 1_000_000;
        addon.log(String.format("Nova scan: %d blocks found in %dms (range=%d)",
            novaBlocks.size(), elapsedMs, range));
    }
    return novaBlocks;
}
```
  </action>
  <verify>
1. Run `mvn clean package -q` - should compile and build successfully
2. Verify no Class.forName() or getMethod() calls remain in captureNovaBlocks, restoreNovaBlocks, or removeNovaBlocks (except in ReflectionCache constructor)
3. Grep for "Class.forName" in the file - should only appear in ReflectionCache constructor and detectNova()
  </verify>
  <done>
All three methods (captureNovaBlocks, restoreNovaBlocks, removeNovaBlocks) use cached reflection. Debug timing is logged when debug mode is enabled. No reflection lookups occur during normal operation - only cached method invocations.
  </done>
</task>

</tasks>

<verification>
After completing all tasks:

1. **Build verification:**
   ```bash
   mvn clean package -q
   ```
   Should succeed without errors.

2. **Code verification:**
   ```bash
   grep -n "Class.forName" src/main/java/world/bentobox/islandselector/integrations/NovaIntegration.java
   ```
   Should only show results in:
   - ReflectionCache constructor (lines where cache is initialized)
   - detectNova() method (initial Nova detection)

3. **Cache verification:**
   ```bash
   grep -n "cache\." src/main/java/world/bentobox/islandselector/integrations/NovaIntegration.java
   ```
   Should show cache usage in captureNovaBlocks, restoreNovaBlocks, removeNovaBlocks.

4. **Timing verification:**
   ```bash
   grep -n "nanoTime" src/main/java/world/bentobox/islandselector/integrations/NovaIntegration.java
   ```
   Should show timing code in the main operation methods.
</verification>

<success_criteria>
1. ReflectionCache inner class exists with all Nova API lookups cached in final fields
2. NovaIntegration has a final `cache` field initialized once in constructor
3. captureNovaBlocks() uses cache instead of per-call reflection lookups
4. restoreNovaBlocks() uses cache instead of per-call reflection lookups
5. removeNovaBlocks() uses cache instead of per-call reflection lookups
6. Debug timing logs scan/restore/remove durations when debug enabled
7. `mvn clean package -q` succeeds
8. No reflection lookups (Class.forName, getMethod) in hot paths
</success_criteria>

<output>
After completion, create `.planning/phases/15-performance-and-polish/15-01-SUMMARY.md`
</output>
