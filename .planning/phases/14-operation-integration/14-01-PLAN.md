---
phase: 14-operation-integration
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/main/java/world/bentobox/islandselector/managers/SlotSwitchManager.java
autonomous: true

must_haves:
  truths:
    - "Slot switching preserves Nova machines (inventory, owner, energy)"
    - "Player sees feedback message about Nova machine preservation after switch"
    - "Multi-dimension slots process Nova blocks in all enabled dimensions"
    - "Nova integration gracefully skips when disabled or unavailable"
  artifacts:
    - path: "src/main/java/world/bentobox/islandselector/managers/SlotSwitchManager.java"
      provides: "Nova block capture/remove/restore in slot switch workflow"
      contains: "captureNovaBlocks"
  key_links:
    - from: "SlotSwitchManager.java"
      to: "NovaIntegration.captureNovaBlocks"
      via: "method call in save phase"
      pattern: "addon\\.getNovaIntegration\\(\\)\\.captureNovaBlocks"
    - from: "SlotSwitchManager.java"
      to: "NovaIntegration.restoreNovaBlocks"
      via: "method call in load phase"
      pattern: "addon\\.getNovaIntegration\\(\\)\\.restoreNovaBlocks"
---

<objective>
Integrate Nova block preservation into SlotSwitchManager workflow

Purpose: Enable players to switch island slots without losing Nova machines (electric furnaces, solar panels, etc.) - their inventory, energy levels, and ownership are preserved across slot switches.

Output: SlotSwitchManager that captures Nova blocks before saving schematic, removes them for clean WorldEdit operation, and restores them after loading new slot's schematic.
</objective>

<execution_context>
@C:\Users\Administrator\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\Administrator\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/14-operation-integration/14-RESEARCH.md
@.planning/phases/12-core-capture-and-restore/12-01-SUMMARY.md
@.planning/phases/13-state-preservation/13-01-SUMMARY.md
@src/main/java/world/bentobox/islandselector/managers/SlotSwitchManager.java
@src/main/java/world/bentobox/islandselector/integrations/NovaIntegration.java
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add Nova block storage fields and helper methods</name>
  <files>src/main/java/world/bentobox/islandselector/managers/SlotSwitchManager.java</files>
  <action>
Add import for NovaIntegration classes at top of file:
```java
import world.bentobox.islandselector.integrations.NovaIntegration.NovaBlockData;
import world.bentobox.islandselector.integrations.NovaIntegration.RestoreResult;
```

Add a Map field to temporarily store Nova blocks during slot switch (between save and load phases):
```java
// Track Nova blocks during slot switch (per-dimension)
private final Map<UUID, Map<String, List<NovaBlockData>>> switchNovaBlocks = new ConcurrentHashMap<>();
```

Add helper methods for Nova integration availability check and multi-dimension Nova processing:

```java
/**
 * Check if Nova integration is available and enabled
 */
private boolean isNovaEnabled() {
    return addon.getNovaIntegration() != null
        && addon.getNovaIntegration().isAvailable()
        && addon.getSettings().isNovaEnabled();
}

/**
 * Capture Nova blocks for all dimensions during slot save.
 * Stores captured blocks in switchNovaBlocks map for later restoration.
 *
 * @param playerUUID Player's UUID
 * @param player Player for progress messages
 * @return true if capture succeeded (or Nova not enabled)
 */
private boolean captureNovaBlocksForSwitch(UUID playerUUID, Player player) {
    if (!isNovaEnabled()) {
        return true;
    }

    Map<String, List<NovaBlockData>> dimensionBlocks = new HashMap<>();

    if (!isMultiDimensionEnabled()) {
        // Single dimension: process overworld only
        World world = addon.getGridManager().getBSkyBlockWorld();
        if (world != null) {
            List<NovaBlockData> blocks = captureNovaBlocksForDimension(playerUUID, world);
            if (blocks != null && !blocks.isEmpty()) {
                dimensionBlocks.put("overworld", blocks);
            }
        }
    } else {
        // Multi-dimension: process all enabled dimensions
        DimensionManager dimManager = addon.getDimensionManager();
        for (DimensionConfig config : dimManager.getEnabledDimensions()) {
            World world = dimManager.getWorld(config.getDimensionKey());
            if (world != null) {
                List<NovaBlockData> blocks = captureNovaBlocksForDimension(playerUUID, world);
                if (blocks != null && !blocks.isEmpty()) {
                    dimensionBlocks.put(config.getDimensionKey(), blocks);
                }
            }
        }
    }

    if (!dimensionBlocks.isEmpty()) {
        switchNovaBlocks.put(playerUUID, dimensionBlocks);
        int totalBlocks = dimensionBlocks.values().stream().mapToInt(List::size).sum();
        addon.log("Captured " + totalBlocks + " Nova blocks across " + dimensionBlocks.size() + " dimension(s) for slot switch");
    }

    return true;
}

/**
 * Capture Nova blocks for a single dimension
 */
private List<NovaBlockData> captureNovaBlocksForDimension(UUID playerUUID, World world) {
    Island island = addon.getIslands().getIsland(world, playerUUID);
    if (island == null) {
        return null;
    }

    Location center = island.getCenter();
    if (center == null || center.getWorld() == null) {
        return null;
    }

    int islandSpacing = addon.getIslandSpacing();
    int protectionRange = island.getProtectionRange();
    int range = Math.max(islandSpacing / 2, protectionRange);

    return addon.getNovaIntegration().captureNovaBlocks(center, range);
}

/**
 * Remove Nova blocks for all dimensions before WorldEdit save.
 * Must be called AFTER captureNovaBlocksForSwitch.
 *
 * @param playerUUID Player's UUID
 */
private void removeNovaBlocksForSwitch(UUID playerUUID) {
    if (!isNovaEnabled()) {
        return;
    }

    Map<String, List<NovaBlockData>> dimensionBlocks = switchNovaBlocks.get(playerUUID);
    if (dimensionBlocks == null || dimensionBlocks.isEmpty()) {
        return;
    }

    if (!isMultiDimensionEnabled()) {
        // Single dimension
        World world = addon.getGridManager().getBSkyBlockWorld();
        if (world != null) {
            List<NovaBlockData> blocks = dimensionBlocks.get("overworld");
            if (blocks != null && !blocks.isEmpty()) {
                removeNovaBlocksForDimension(playerUUID, world, blocks);
            }
        }
    } else {
        // Multi-dimension
        DimensionManager dimManager = addon.getDimensionManager();
        for (DimensionConfig config : dimManager.getEnabledDimensions()) {
            List<NovaBlockData> blocks = dimensionBlocks.get(config.getDimensionKey());
            if (blocks != null && !blocks.isEmpty()) {
                World world = dimManager.getWorld(config.getDimensionKey());
                if (world != null) {
                    removeNovaBlocksForDimension(playerUUID, world, blocks);
                }
            }
        }
    }
}

/**
 * Remove Nova blocks for a single dimension
 */
private void removeNovaBlocksForDimension(UUID playerUUID, World world, List<NovaBlockData> blocks) {
    Island island = addon.getIslands().getIsland(world, playerUUID);
    if (island == null || island.getCenter() == null) {
        return;
    }

    addon.getNovaIntegration().removeNovaBlocks(blocks, island.getCenter());
}

/**
 * Restore Nova blocks for all dimensions after WorldEdit load.
 * Uses blocks stored from the target slot (not the source slot).
 *
 * @param playerUUID Player's UUID
 * @param player Player for feedback messages
 * @param toSlotNumber Target slot number (to load Nova blocks from storage)
 */
private void restoreNovaBlocksForSwitch(UUID playerUUID, Player player, int toSlotNumber) {
    if (!isNovaEnabled()) {
        return;
    }

    // Load Nova blocks from slot storage (if any were saved for this slot)
    Map<String, List<NovaBlockData>> dimensionBlocks = addon.getSlotManager()
        .loadNovaBlocks(playerUUID, toSlotNumber);

    if (dimensionBlocks == null || dimensionBlocks.isEmpty()) {
        return;
    }

    int totalMachinesRestored = 0;
    int totalMachinesFailed = 0;

    if (!isMultiDimensionEnabled()) {
        // Single dimension
        List<NovaBlockData> blocks = dimensionBlocks.get("overworld");
        if (blocks != null && !blocks.isEmpty()) {
            World world = addon.getGridManager().getBSkyBlockWorld();
            if (world != null) {
                RestoreResult result = restoreNovaBlocksForDimension(playerUUID, world, blocks);
                totalMachinesRestored += result.machinesRestored;
                totalMachinesFailed += result.machinesFailed;
            }
        }
    } else {
        // Multi-dimension
        DimensionManager dimManager = addon.getDimensionManager();
        for (DimensionConfig config : dimManager.getEnabledDimensions()) {
            List<NovaBlockData> blocks = dimensionBlocks.get(config.getDimensionKey());
            if (blocks != null && !blocks.isEmpty()) {
                World world = dimManager.getWorld(config.getDimensionKey());
                if (world != null) {
                    RestoreResult result = restoreNovaBlocksForDimension(playerUUID, world, blocks);
                    totalMachinesRestored += result.machinesRestored;
                    totalMachinesFailed += result.machinesFailed;
                }
            }
        }
    }

    // Send feedback to player
    RestoreResult combinedResult = new RestoreResult(totalMachinesRestored, totalMachinesFailed);
    String message = combinedResult.getFeedbackMessage();
    if (message != null) {
        sendProgress(player, "&a" + message);
    }
}

/**
 * Restore Nova blocks for a single dimension
 */
private RestoreResult restoreNovaBlocksForDimension(UUID playerUUID, World world, List<NovaBlockData> blocks) {
    Island island = addon.getIslands().getIsland(world, playerUUID);
    if (island == null || island.getCenter() == null) {
        return new RestoreResult(0, 0);
    }

    return addon.getNovaIntegration().restoreNovaBlocks(blocks, island.getCenter());
}
```

Also add import for HashMap:
```java
import java.util.HashMap;
```
  </action>
  <verify>
Search for "captureNovaBlocksForSwitch" and "restoreNovaBlocksForSwitch" in SlotSwitchManager.java to confirm methods exist.
Run `mvn clean package -q` to verify compilation.
  </verify>
  <done>
SlotSwitchManager has Nova helper methods: isNovaEnabled(), captureNovaBlocksForSwitch(), removeNovaBlocksForSwitch(), restoreNovaBlocksForSwitch() with multi-dimension support.
  </done>
</task>

<task type="auto">
  <name>Task 2: Integrate Nova capture/remove/restore into slot switch workflow</name>
  <files>src/main/java/world/bentobox/islandselector/managers/SlotSwitchManager.java</files>
  <action>
In `performSlotSwitchAsync` method, add Nova block handling at the correct lifecycle points:

**Step 1: After Step 1.7 (saving island homes), add Nova capture and remove:**

Find the line:
```java
// Step 2: Save current island to schematic (multi-dimension aware)
sendProgress(player, "&eSaving current island...");
```

Insert BEFORE this line:
```java
// Step 1.8: Capture and remove Nova blocks before schematic save
if (isNovaEnabled()) {
    sendProgress(player, "&eCapturing Nova machines...");
    captureNovaBlocksForSwitch(playerUUID, player);
    removeNovaBlocksForSwitch(playerUUID);
}

// Save captured Nova blocks for the current slot (for later restoration when switching back)
Map<String, List<NovaBlockData>> capturedNova = switchNovaBlocks.remove(playerUUID);
if (capturedNova != null && !capturedNova.isEmpty()) {
    addon.getSlotManager().saveNovaBlocks(playerUUID, fromSlot.getSlotNumber(), capturedNova);
}
```

**Step 2: After Step 4.6 (restoring island homes), add Nova restore:**

Find the line:
```java
// Step 4.7: Update blueprint permissions for the target slot
```

Insert BEFORE this line:
```java
// Step 4.65: Restore Nova blocks for the target slot
if (isNovaEnabled()) {
    sendProgress(player, "&eRestoring Nova machines...");
    restoreNovaBlocksForSwitch(playerUUID, player, toSlotNumber);
}
```

**Step 3: Add cleanup on error paths:**

In the catch block at the end of performSlotSwitchAsync, add cleanup:
```java
// Clean up any captured Nova blocks on error
switchNovaBlocks.remove(playerUUID);
```

Also ensure cleanup happens when switch is cancelled (in the event cancellation handler).
  </action>
  <verify>
1. Search for "Capturing Nova machines" and "Restoring Nova machines" progress messages in SlotSwitchManager.java
2. Search for "saveNovaBlocks" and "loadNovaBlocks" calls
3. Run `mvn clean package -q` to verify compilation
4. Verify SlotManager has saveNovaBlocks/loadNovaBlocks methods (if not, they need to be added - see task 3)
  </verify>
  <done>
Slot switch workflow captures Nova blocks before save, removes them for clean WorldEdit copy, saves them to slot storage, loads stored Nova blocks for target slot, and restores them after WorldEdit paste with player feedback.
  </done>
</task>

<task type="auto">
  <name>Task 3: Add Nova block storage methods to SlotManager</name>
  <files>src/main/java/world/bentobox/islandselector/managers/SlotManager.java</files>
  <action>
SlotManager needs methods to persist Nova blocks per slot per dimension.

Add import at top:
```java
import world.bentobox.islandselector.integrations.NovaIntegration.NovaBlockData;
import java.io.*;
```

Add methods for saving and loading Nova blocks:

```java
/**
 * Save Nova blocks for a slot.
 * Stores to: slots/{playerUUID}/slot-{number}.nova
 *
 * @param playerUUID Player UUID
 * @param slotNumber Slot number
 * @param novaBlocks Map of dimension key to Nova block list
 */
public void saveNovaBlocks(UUID playerUUID, int slotNumber, Map<String, List<NovaBlockData>> novaBlocks) {
    if (novaBlocks == null || novaBlocks.isEmpty()) {
        return;
    }

    File novaFile = getNovaBlocksFile(playerUUID, slotNumber);
    novaFile.getParentFile().mkdirs();

    try (ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream(novaFile))) {
        oos.writeObject(novaBlocks);
        addon.log("Saved Nova blocks for player " + playerUUID + " slot " + slotNumber);
    } catch (IOException e) {
        addon.logError("Failed to save Nova blocks for slot " + slotNumber + ": " + e.getMessage());
    }
}

/**
 * Load Nova blocks for a slot.
 *
 * @param playerUUID Player UUID
 * @param slotNumber Slot number
 * @return Map of dimension key to Nova block list, or null if none saved
 */
@SuppressWarnings("unchecked")
public Map<String, List<NovaBlockData>> loadNovaBlocks(UUID playerUUID, int slotNumber) {
    File novaFile = getNovaBlocksFile(playerUUID, slotNumber);
    if (!novaFile.exists()) {
        return null;
    }

    try (ObjectInputStream ois = new ObjectInputStream(new FileInputStream(novaFile))) {
        Object obj = ois.readObject();
        if (obj instanceof Map) {
            addon.log("Loaded Nova blocks for player " + playerUUID + " slot " + slotNumber);
            return (Map<String, List<NovaBlockData>>) obj;
        }
    } catch (IOException | ClassNotFoundException e) {
        addon.logError("Failed to load Nova blocks for slot " + slotNumber + ": " + e.getMessage());
    }

    return null;
}

/**
 * Get the file path for Nova blocks storage
 */
private File getNovaBlocksFile(UUID playerUUID, int slotNumber) {
    File slotDir = new File(addon.getDataFolder(), "slots" + File.separator + playerUUID.toString());
    return new File(slotDir, "slot-" + slotNumber + ".nova");
}

/**
 * Delete Nova blocks file when slot is deleted
 */
public void deleteNovaBlocks(UUID playerUUID, int slotNumber) {
    File novaFile = getNovaBlocksFile(playerUUID, slotNumber);
    if (novaFile.exists()) {
        if (novaFile.delete()) {
            addon.log("Deleted Nova blocks file for player " + playerUUID + " slot " + slotNumber);
        }
    }
}
```
  </action>
  <verify>
1. Search for "saveNovaBlocks" and "loadNovaBlocks" methods in SlotManager.java
2. Run `mvn clean package -q` to verify compilation
3. Verify imports are present for ObjectOutputStream, ObjectInputStream, FileInputStream, FileOutputStream
  </verify>
  <done>
SlotManager has methods to persist Nova blocks: saveNovaBlocks(UUID, int, Map), loadNovaBlocks(UUID, int) returning Map, getNovaBlocksFile(UUID, int), deleteNovaBlocks(UUID, int).
  </done>
</task>

</tasks>

<verification>
1. Build passes: `mvn clean package -q` completes without errors
2. SlotSwitchManager imports NovaBlockData and RestoreResult
3. SlotSwitchManager has isNovaEnabled() method
4. SlotSwitchManager has captureNovaBlocksForSwitch() and restoreNovaBlocksForSwitch() methods
5. performSlotSwitchAsync has "Capturing Nova machines" and "Restoring Nova machines" progress messages
6. SlotManager has saveNovaBlocks() and loadNovaBlocks() methods
7. Nova blocks are captured before schematic save and restored after schematic load
</verification>

<success_criteria>
- Build compiles without errors
- Slot switching captures Nova blocks before WorldEdit save operation
- Captured Nova blocks are persisted to slot-specific .nova files
- Nova blocks are restored after WorldEdit load operation from target slot's storage
- Player receives feedback message about Nova machine preservation
- Multi-dimension islands process Nova blocks in all enabled dimensions
- Nova integration gracefully skips when disabled or unavailable
</success_criteria>

<output>
After completion, create `.planning/phases/14-operation-integration/14-01-SUMMARY.md`
</output>
