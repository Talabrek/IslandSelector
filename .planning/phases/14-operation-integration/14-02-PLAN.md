---
phase: 14-operation-integration
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - src/main/java/world/bentobox/islandselector/managers/RelocationManager.java
autonomous: true

must_haves:
  truths:
    - "Island relocation preserves Nova machines (inventory, owner, energy)"
    - "Player sees feedback message about Nova machine preservation after relocation"
    - "Multi-dimension relocations process Nova blocks in all enabled dimensions"
    - "Nova integration gracefully skips when disabled or unavailable"
  artifacts:
    - path: "src/main/java/world/bentobox/islandselector/managers/RelocationManager.java"
      provides: "Nova block capture/remove/restore in relocation workflow"
      contains: "captureNovaBlocks"
  key_links:
    - from: "RelocationManager.java"
      to: "NovaIntegration.captureNovaBlocks"
      via: "method call before WorldEdit copy"
      pattern: "addon\\.getNovaIntegration\\(\\)\\.captureNovaBlocks"
    - from: "RelocationManager.java"
      to: "NovaIntegration.restoreNovaBlocks"
      via: "method call after WorldEdit paste"
      pattern: "addon\\.getNovaIntegration\\(\\)\\.restoreNovaBlocks"
---

<objective>
Integrate Nova block preservation into RelocationManager workflow

Purpose: Enable players to relocate their island to a new grid position without losing Nova machines (electric furnaces, solar panels, etc.) - their inventory, energy levels, and ownership are preserved through the move.

Output: RelocationManager that captures Nova blocks from source location, removes them for clean WorldEdit copy, and restores them at the new target location after paste.
</objective>

<execution_context>
@C:\Users\Administrator\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\Administrator\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/14-operation-integration/14-RESEARCH.md
@.planning/phases/12-core-capture-and-restore/12-01-SUMMARY.md
@.planning/phases/13-state-preservation/13-01-SUMMARY.md
@src/main/java/world/bentobox/islandselector/managers/RelocationManager.java
@src/main/java/world/bentobox/islandselector/integrations/NovaIntegration.java
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add Nova block storage and helper methods to RelocationManager</name>
  <files>src/main/java/world/bentobox/islandselector/managers/RelocationManager.java</files>
  <action>
Add imports for NovaIntegration classes at top of file:
```java
import world.bentobox.islandselector.integrations.NovaIntegration.NovaBlockData;
import world.bentobox.islandselector.integrations.NovaIntegration.RestoreResult;
```

Add a Map field to temporarily store Nova blocks during relocation (between source copy and target paste):
```java
// Track Nova blocks during relocation (per-dimension)
private final Map<UUID, Map<String, List<NovaBlockData>>> relocationNovaBlocks = new ConcurrentHashMap<>();
```

Add helper methods for Nova integration:

```java
/**
 * Check if Nova integration is available and enabled
 */
private boolean isNovaEnabled() {
    return addon.getNovaIntegration() != null
        && addon.getNovaIntegration().isAvailable()
        && addon.getSettings().isNovaEnabled();
}

/**
 * Capture Nova blocks from source island for all dimensions.
 * Stores captured blocks in relocationNovaBlocks map for later restoration.
 *
 * @param playerUUID Player's UUID
 * @param player Player for progress messages
 * @return true if capture succeeded (or Nova not enabled)
 */
private boolean captureNovaBlocksForRelocation(UUID playerUUID, Player player) {
    if (!isNovaEnabled()) {
        return true;
    }

    Map<String, List<NovaBlockData>> dimensionBlocks = new HashMap<>();

    if (!isMultiDimensionEnabled()) {
        // Single dimension: process overworld only
        World world = addon.getGridManager().getBSkyBlockWorld();
        if (world != null) {
            List<NovaBlockData> blocks = captureNovaBlocksForDimension(playerUUID, world);
            if (blocks != null && !blocks.isEmpty()) {
                dimensionBlocks.put("overworld", blocks);
            }
        }
    } else {
        // Multi-dimension: process all enabled dimensions
        DimensionManager dimManager = addon.getDimensionManager();
        for (DimensionConfig config : dimManager.getEnabledDimensions()) {
            World world = dimManager.getWorld(config.getDimensionKey());
            if (world != null) {
                List<NovaBlockData> blocks = captureNovaBlocksForDimension(playerUUID, world);
                if (blocks != null && !blocks.isEmpty()) {
                    dimensionBlocks.put(config.getDimensionKey(), blocks);
                }
            }
        }
    }

    if (!dimensionBlocks.isEmpty()) {
        relocationNovaBlocks.put(playerUUID, dimensionBlocks);
        int totalBlocks = dimensionBlocks.values().stream().mapToInt(List::size).sum();
        addon.log("Captured " + totalBlocks + " Nova blocks across " + dimensionBlocks.size() + " dimension(s) for relocation");
    }

    return true;
}

/**
 * Capture Nova blocks for a single dimension
 */
private List<NovaBlockData> captureNovaBlocksForDimension(UUID playerUUID, World world) {
    Island island = addon.getIslands().getIsland(world, playerUUID);
    if (island == null) {
        return null;
    }

    Location center = island.getCenter();
    if (center == null || center.getWorld() == null) {
        return null;
    }

    int islandSpacing = addon.getIslandSpacing();
    int protectionRange = island.getProtectionRange();
    int range = Math.max(islandSpacing / 2, protectionRange);

    return addon.getNovaIntegration().captureNovaBlocks(center, range);
}

/**
 * Remove Nova blocks from source island before WorldEdit copy.
 * Must be called AFTER captureNovaBlocksForRelocation.
 *
 * @param playerUUID Player's UUID
 */
private void removeNovaBlocksForRelocation(UUID playerUUID) {
    if (!isNovaEnabled()) {
        return;
    }

    Map<String, List<NovaBlockData>> dimensionBlocks = relocationNovaBlocks.get(playerUUID);
    if (dimensionBlocks == null || dimensionBlocks.isEmpty()) {
        return;
    }

    if (!isMultiDimensionEnabled()) {
        // Single dimension
        World world = addon.getGridManager().getBSkyBlockWorld();
        if (world != null) {
            List<NovaBlockData> blocks = dimensionBlocks.get("overworld");
            if (blocks != null && !blocks.isEmpty()) {
                removeNovaBlocksForDimension(playerUUID, world, blocks);
            }
        }
    } else {
        // Multi-dimension
        DimensionManager dimManager = addon.getDimensionManager();
        for (DimensionConfig config : dimManager.getEnabledDimensions()) {
            List<NovaBlockData> blocks = dimensionBlocks.get(config.getDimensionKey());
            if (blocks != null && !blocks.isEmpty()) {
                World world = dimManager.getWorld(config.getDimensionKey());
                if (world != null) {
                    removeNovaBlocksForDimension(playerUUID, world, blocks);
                }
            }
        }
    }
}

/**
 * Remove Nova blocks for a single dimension
 */
private void removeNovaBlocksForDimension(UUID playerUUID, World world, List<NovaBlockData> blocks) {
    Island island = addon.getIslands().getIsland(world, playerUUID);
    if (island == null || island.getCenter() == null) {
        return;
    }

    addon.getNovaIntegration().removeNovaBlocks(blocks, island.getCenter());
}

/**
 * Restore Nova blocks at target location after WorldEdit paste.
 * Uses blocks captured from source location.
 *
 * @param playerUUID Player's UUID
 * @param player Player for feedback messages
 * @param targetCenter Target island center location (for offset calculation)
 */
private void restoreNovaBlocksForRelocation(UUID playerUUID, Player player, Location targetCenter) {
    if (!isNovaEnabled()) {
        return;
    }

    Map<String, List<NovaBlockData>> dimensionBlocks = relocationNovaBlocks.remove(playerUUID);
    if (dimensionBlocks == null || dimensionBlocks.isEmpty()) {
        return;
    }

    int totalMachinesRestored = 0;
    int totalMachinesFailed = 0;

    if (!isMultiDimensionEnabled()) {
        // Single dimension
        List<NovaBlockData> blocks = dimensionBlocks.get("overworld");
        if (blocks != null && !blocks.isEmpty()) {
            World world = addon.getGridManager().getBSkyBlockWorld();
            if (world != null) {
                // Get the NEW island center after relocation
                Island island = addon.getIslands().getIsland(world, playerUUID);
                if (island != null && island.getCenter() != null) {
                    RestoreResult result = addon.getNovaIntegration().restoreNovaBlocks(blocks, island.getCenter());
                    totalMachinesRestored += result.machinesRestored;
                    totalMachinesFailed += result.machinesFailed;
                }
            }
        }
    } else {
        // Multi-dimension
        DimensionManager dimManager = addon.getDimensionManager();
        for (DimensionConfig config : dimManager.getEnabledDimensions()) {
            List<NovaBlockData> blocks = dimensionBlocks.get(config.getDimensionKey());
            if (blocks != null && !blocks.isEmpty()) {
                World world = dimManager.getWorld(config.getDimensionKey());
                if (world != null) {
                    // Get the NEW island center after relocation
                    Island island = addon.getIslands().getIsland(world, playerUUID);
                    if (island != null && island.getCenter() != null) {
                        RestoreResult result = addon.getNovaIntegration().restoreNovaBlocks(blocks, island.getCenter());
                        totalMachinesRestored += result.machinesRestored;
                        totalMachinesFailed += result.machinesFailed;
                    }
                }
            }
        }
    }

    // Send feedback to player
    RestoreResult combinedResult = new RestoreResult(totalMachinesRestored, totalMachinesFailed);
    String message = combinedResult.getFeedbackMessage();
    if (message != null) {
        player.sendMessage(colorize("&a" + message));
    }

    // Log warnings if failures occurred
    if (combinedResult.hasFailures()) {
        addon.logWarning("Some Nova machines failed to restore during relocation for " + playerUUID);
    }
}
```

Also add import for HashMap if not present:
```java
import java.util.HashMap;
```
  </action>
  <verify>
Search for "captureNovaBlocksForRelocation" and "restoreNovaBlocksForRelocation" in RelocationManager.java to confirm methods exist.
Run `mvn clean package -q` to verify compilation.
  </verify>
  <done>
RelocationManager has Nova helper methods: isNovaEnabled(), captureNovaBlocksForRelocation(), removeNovaBlocksForRelocation(), restoreNovaBlocksForRelocation() with multi-dimension support.
  </done>
</task>

<task type="auto">
  <name>Task 2: Integrate Nova handling into relocation workflow</name>
  <files>src/main/java/world/bentobox/islandselector/managers/RelocationManager.java</files>
  <action>
Find the main relocation method (likely `relocateIsland` or `performRelocation`) and add Nova handling at the correct lifecycle points.

The relocation workflow typically:
1. Validates relocation is possible
2. Charges player (if cost configured)
3. Copies island from source to target
4. Clears source location
5. Updates BentoBox island data
6. Teleports players

**Step 1: Add Nova capture BEFORE WorldEdit copy operation:**

Find where the source island is copied (look for schematicUtils.copyAndSave or similar).

Insert BEFORE the copy operation:
```java
// Capture Nova blocks before WorldEdit copy
if (isNovaEnabled()) {
    player.sendMessage(colorize("&eCapturing Nova machines..."));
    captureNovaBlocksForRelocation(playerUUID, player);
    removeNovaBlocksForRelocation(playerUUID);
}
```

**Step 2: Add Nova restore AFTER WorldEdit paste operation:**

Find where the island is pasted at the target location (look for schematicUtils.loadAndPaste or similar).

Insert AFTER the paste operation completes:
```java
// Restore Nova blocks at new location
if (isNovaEnabled()) {
    player.sendMessage(colorize("&eRestoring Nova machines..."));
    restoreNovaBlocksForRelocation(playerUUID, player, targetCenter);
}
```

**Step 3: Add cleanup on error paths:**

In any catch blocks or error handlers, add cleanup:
```java
// Clean up any captured Nova blocks on error
relocationNovaBlocks.remove(playerUUID);
```

Also clean up if relocation is cancelled before completion.

**Important:** The exact location of these integration points depends on the existing relocation workflow structure. The key is:
- Capture and remove BEFORE WorldEdit copies the source
- Restore AFTER WorldEdit pastes at target (and AFTER island center is updated in BentoBox)
  </action>
  <verify>
1. Search for "Capturing Nova machines" and "Restoring Nova machines" messages in RelocationManager.java
2. Verify capture happens before any schematic copy operation
3. Verify restore happens after paste operation and island center update
4. Run `mvn clean package -q` to verify compilation
  </verify>
  <done>
Relocation workflow captures Nova blocks from source, removes them before WorldEdit copy, and restores them at target location after WorldEdit paste, with player feedback messages.
  </done>
</task>

</tasks>

<verification>
1. Build passes: `mvn clean package -q` completes without errors
2. RelocationManager imports NovaBlockData and RestoreResult
3. RelocationManager has isNovaEnabled() method
4. RelocationManager has captureNovaBlocksForRelocation() and restoreNovaBlocksForRelocation() methods
5. Relocation workflow has "Capturing Nova machines" and "Restoring Nova machines" messages
6. Nova blocks are captured from source before WorldEdit copy
7. Nova blocks are restored at target after WorldEdit paste
8. Player receives feedback about Nova machine preservation
</verification>

<success_criteria>
- Build compiles without errors
- Island relocation captures Nova blocks from source location
- Nova blocks are removed before WorldEdit copy (prevents data corruption)
- Nova blocks are restored at target location after paste
- Player receives feedback message about Nova machine preservation
- Multi-dimension islands process Nova blocks in all enabled dimensions
- Nova integration gracefully skips when disabled or unavailable
- Cleanup occurs on error paths to prevent memory leaks
</success_criteria>

<output>
After completion, create `.planning/phases/14-operation-integration/14-02-SUMMARY.md`
</output>
